<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>虛擬貨幣價格預測與風險警示 AI — 範例 App</title>
  <style>
    body{font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial; padding:20px; max-width:980px; margin:0 auto; background:#f7f9fc}
    header{margin-bottom:14px}
    h1{font-size:20px;margin:0}
    .card{background:#fff;border-radius:10px;padding:14px;margin:12px 0;box-shadow:0 1px 3px rgba(0,0,0,0.06)}
    label{display:block;margin:8px 0 6px;font-weight:600}
    textarea, input, select{width:100%;padding:8px;border-radius:8px;border:1px solid #d9dbe0}
    button{padding:10px 14px;border-radius:8px;border:0;background:#0b74de;color:#fff;cursor:pointer}
    pre{background:#f2f4f7;padding:12px;border-radius:8px;white-space:pre-wrap}
    .row{display:flex;gap:12px}
    .col{flex:1}
    canvas{max-width:100%;}
    .meta{font-size:13px;color:#666;margin-top:8px}
  </style>
</head>
<body>
  <header>
    <h1>虛擬貨幣價格預測與風險警示 AI — 單檔示範</h1>
    <p class="meta">此範例為前端原型，可本地離線執行或串接 OpenAI API（說明在下方）。包含：提示詞自動生成、模擬預測、JSON 輸出與價格走勢視覺化。</p>
  </header>

  <section class="card">
    <h2>輸入區</h2>
    <label>幣種名稱</label>
    <input id="coin" placeholder="例如：Bitcoin (BTC)" value="Bitcoin (BTC)" />

    <label>最近 7 日價格（以逗號分隔，從最早到最新）</label>
    <input id="prices" placeholder="例：63000,63500,62800,64000,65000,64800,65500" value="63000,63500,62800,64000,65000,64800,65500" />

    <label>最新新聞或社群摘要（可填 1-3 則）</label>
    <textarea id="news" rows="3" placeholder="例：某大交易所宣布支援、監管新聞、社群討論熱度上升...">某大交易所宣布支援；推特討論熱度上升；監管風險仍存在</textarea>

    <label>整體市場情緒</label>
    <select id="sentiment">
      <option value="Positive">Positive</option>
      <option value="Neutral" selected>Neutral</option>
      <option value="Negative">Negative</option>
    </select>

    <div style="margin-top:12px;display:flex;gap:10px">
      <button id="gen">生成提示詞 & 模擬預測</button>
      <button id="callApi">（選用）呼叫 OpenAI API</button>
    </div>

    <p class="meta">說明：若要實際呼叫 OpenAI，請在下方 <strong>CALL_OPENAI</strong> 變數填入你的 API KEY，並確保後端安全存放金鑰（示範僅供快速測試，不建議把金鑰放在前端）。</p>
  </section>

  <section class="card">
    <h2>生成的提示詞（Prompt）</h2>
    <pre id="promptOut">尚未生成</pre>
  </section>

  <section class="card">
    <h2>AI 輸出（JSON）</h2>
    <pre id="resultOut">尚未產出</pre>
  </section>

  <section class="card">
    <h2>價格走勢視覺化</h2>
    <canvas id="priceChart" width="800" height="300"></canvas>
  </section>

  <section class="card">
    <h2>快速說明：提示詞模板</h2>
    <pre>
你是一位金融資料分析專家，專注於加密貨幣市場趨勢預測。
任務：根據提供的虛擬貨幣資料，分析未來 7 日的漲跌趨勢與風險等級。
輸入資料：
- 幣種名稱：{幣名}
- 最近 7 日價格：{價格清單}
- 最新 3 則新聞摘要或社群討論：{文字}
- 市場整體情緒：{情緒狀態}
請輸出 JSON：{risk_level, trend, confidence, reasons[], advice}
    </pre>
  </section>

  <footer class="meta card">
    <strong>下一步建議：</strong>若要做競賽或產品化，建議：1) 在後端串接可靠的價格 API（如 CoinGecko、Binance）、2) 建立新聞與社群抓取 pipeline，3) 在後端呼叫大型語言模型以保護金鑰並批量處理請求，4) 用真實標註資料微調或建立輔助統計模型提升準確性。
  </footer>

  <script>
    // 若要在本地測試呼叫 OpenAI：
    // - 建議把 API Key 放在後端，前端呼叫你自己的 API。
    // - 以下為示範（請勿在公開網頁直接放 KEY）。
    const CALL_OPENAI = null; // 若要前端測試，可暫時填 'sk-...'(不安全)

    const genBtn = document.getElementById('gen');
    const callBtn = document.getElementById('callApi');
    const promptOut = document.getElementById('promptOut');
    const resultOut = document.getElementById('resultOut');

    genBtn.addEventListener('click', ()=>{
      const prompt = buildPrompt();
      promptOut.textContent = prompt;
      const sim = simulatePredict();
      resultOut.textContent = JSON.stringify(sim, null, 2);
      renderChart(sim.prices, sim.predictionPoint ? sim.prices.concat([sim.predictionPoint]) : sim.prices);
    });

    callBtn.addEventListener('click', async ()=>{
      if(!CALL_OPENAI){
        alert('CALL_OPENAI 未設定。請在程式中填入 API Key（僅供測試）。建議將金鑰放在後端。');
        return;
      }
      const prompt = buildPrompt();
      promptOut.textContent = prompt;
      const apiResp = await callOpenAI(prompt);
      resultOut.textContent = apiResp;
    });

    function buildPrompt(){
      const coin = document.getElementById('coin').value.trim();
      const prices = document.getElementById('prices').value.trim();
      const news = document.getElementById('news').value.trim();
      const sentiment = document.getElementById('sentiment').value;
      return `你是一位金融資料分析專家，專注於加密貨幣市場趨勢預測。

任務：根據提供的虛擬貨幣資料，分析未來 7 日的漲跌趨勢與風險等級。

輸入資料：
- 幣種名稱：${coin}
- 最近 7 日價格：${prices}
- 最新 3 則新聞或社群摘要：${news}
- 市場整體情緒：${sentiment}

請以 JSON 格式回覆：{
 "risk_level": "(高/中/低)",
 "trend": "(上漲/下跌/持平)",
 "confidence": "(數值%)",
 "reasons": ["...","...","..."],
 "advice": "不超過100字的投資/風險建議"
}

請使用繁體中文。`;
    }

    // 簡單模擬預測：用移動平均與價格變化做 heuristic
    function simulatePredict(){
      const pricesStr = document.getElementById('prices').value.trim();
      const prices = pricesStr.split(',').map(s=>parseFloat(s)).filter(n=>!isNaN(n));
      const news = document.getElementById('news').value.trim();
      const sentiment = document.getElementById('sentiment').value;

      // 基本統計
      const last = prices[prices.length-1];
      const avg = prices.reduce((a,b)=>a+b,0)/prices.length;
      const diff = last - avg;

      // 簡單 trend 判斷
      let trend = '持平';
      if(diff > avg*0.02) trend = '上漲';
      if(diff < -avg*0.02) trend = '下跌';

      // sentiment 與 news 影響信心
      let confidence = 50 + Math.min(30, Math.round(Math.abs(diff)/avg*100));
      if(sentiment === 'Positive') confidence += 10;
      if(sentiment === 'Negative') confidence -= 10;
      confidence = Math.max(20, Math.min(95, confidence));

      // risk heuristic
      let risk = '中';
      if(confidence < 40 || /監管|封鎖|詐騙|禁止/.test(news)) risk = '高';
      if(confidence > 70 && /支援|採用|整合|升級/.test(news)) risk = '低';

      // reasons
      const reasons = [];
      reasons.push(`最後價格 ${last}，與 7 日平均 ${avg.toFixed(2)} 差異 ${diff.toFixed(2)}`);
      reasons.push(`市場情緒：${sentiment}`);
      if(/監管|詐騙|下架/.test(news)) reasons.push('新聞中出現負面關鍵字，增加不確定性');
      else reasons.push('近期無明確負面新聞');

      // advice
      let advice = '保持觀察，必要時設定停損。';
      if(risk === '高') advice = '風險偏高，建議減倉或設定嚴格停損。';
      if(risk === '低') advice = '風險較低，但仍建議分散投資與設定風險控管。';

      // 模擬下一日預測點（簡單線性外推）
      const predictionPoint = parseFloat((last + (last - prices[prices.length-2] || 0)).toFixed(2));

      return {
        risk_level: risk,
        trend: trend,
        confidence: confidence + '%',
        reasons: reasons,
        advice: advice,
        prices: prices,
        predictionPoint: predictionPoint
      };
    }

    // 簡單 Chart (使用 Canvas API，不依賴外部套件)
    function renderChart(originalPrices, displayPrices){
      const canvas = document.getElementById('priceChart');
      const ctx = canvas.getContext('2d');
      const w = canvas.width = canvas.parentElement.clientWidth - 40;
      const h = canvas.height = 300;

      // clear
      ctx.clearRect(0,0,w,h);
      if(!displayPrices || displayPrices.length===0) return;

      const max = Math.max(...displayPrices);
      const min = Math.min(...displayPrices);
      const pad = 30;
      const stepX = (w - pad*2) / (displayPrices.length - 1);

      // axes
      ctx.strokeStyle = '#e6e9ee';
      ctx.lineWidth = 1;
      ctx.beginPath(); ctx.moveTo(pad, pad); ctx.lineTo(pad, h-pad); ctx.lineTo(w-pad, h-pad); ctx.stroke();

      // draw line
      ctx.beginPath();
      displayPrices.forEach((p,i)=>{
        const x = pad + i * stepX;
        const y = pad + (1 - (p - min)/(max - min || 1)) * (h - pad*2);
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      });
      ctx.strokeStyle = '#0b74de'; ctx.lineWidth = 2; ctx.stroke();

      // mark prediction point if exists
      if(displayPrices.length > originalPrices.length){
        const i = displayPrices.length -1;
        const p = displayPrices[i];
        const x = pad + i * stepX;
        const y = pad + (1 - (p - min)/(max - min || 1)) * (h - pad*2);
        ctx.fillStyle = '#ff6b6b';
        ctx.beginPath(); ctx.arc(x,y,5,0,Math.PI*2); ctx.fill();
        ctx.font = '12px Arial'; ctx.fillText('預測', x+8, y-8);
      }

      // price labels (min/max)
      ctx.fillStyle = '#333'; ctx.font = '12px Arial';
      ctx.fillText(max.toFixed(2), 8, pad+6);
      ctx.fillText(min.toFixed(2), 8, h-pad+4);
    }

    // 示範呼叫 OpenAI（簡單示意）
    async function callOpenAI(prompt){
      try{
        const res = await fetch('https://api.openai.com/v1/chat/completions',{
          method:'POST',
          headers: {
            'Content-Type':'application/json',
            'Authorization': 'Bearer ' + CALL_OPENAI
          },
          body: JSON.stringify({model:'gpt-4o-mini', messages:[{role:'user', content:prompt}], max_tokens:600})
        });
        const data = await res.json();
        // 嘗試解析模型回傳的文字
        return JSON.stringify(data, null, 2);
      }catch(err){
        return '呼叫失敗：' + err.message;
      }
    }

    // 初始化示範 chart
    document.addEventListener('DOMContentLoaded', ()=>{
      const sim = simulatePredict();
      renderChart(sim.prices, sim.prices);
    });
  </script>
</body>
</html>
